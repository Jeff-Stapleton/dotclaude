---
name: refinement
description: "Decompose a product requirement brief, technical architecture, and Storybook designs into user-story specs ordered by dependency and value, then produce an implementation plan. Pass --review to enable dual-agent spec reviews."
user_invocable: true
---

# Refinement Skill

Decompose foundational project documents into implementation-ready specifications organized around **user stories** — vertical slices that each deliver incremental value. Every spec covers UI, API, data, and tests for one capability so that each completed story results in a working, testable increment.

## Argument Handling

```
/refinement <path/to/product-requirement-brief.md> [--review]
```

- **First argument** (required): Path to the product requirement brief.
- **`--review` flag** (optional): When present, enables Phase 3 (dual-agent spec reviews). When omitted, Phase 3 is skipped entirely.

If the first argument is missing, use `AskUserQuestion` to request the PRB path.

The skill expects these files to exist in the same directory as the PRB:
- `technical-architecture.md` — generated by the `/technical-architecture` skill
- Storybook stories (`.stories.tsx` files) — optional, generated by `/storybook-builder`

If `technical-architecture.md` is not found alongside the PRB, use `AskUserQuestion` to request its path.

---

## Resumability Protocol

Before starting any phase, check if `refinement-progress.json` exists in the same directory as the PRB.

If the file exists, read it and determine the current state:
- **`phase: "manifest"`** — Phase 1 completed. Skip to Phase 2.
- **`phase: "specs"`** — Phase 2 was in progress. Read the `stories` object — any story with `"status": "done"` is already written. Resume Phase 2, skipping completed stories.
- **`phase: "reviews"`** — Phase 3 was in progress. Resume reviews for stories not yet reviewed.
- **`phase: "plan"`** — Phase 4 completed. Skip to Phase 5.
- **`phase: "complete"`** — All phases done. Print the summary and exit.

If the file does not exist, start from Phase 1.

**Print a status line when resuming:** `Resuming from phase: {phase} — {n} of {total} stories already complete`

---

## Execution Phases

Run these five phases sequentially. Do not skip phases (unless resuming — see above). If `--review` was not passed, skip Phase 3 entirely.

---

### Phase 1 — Ingest & Decompose

**Goal:** Read all inputs, decompose requirements into user stories, and produce a compact manifest so the full documents never need to stay in context.

#### Step 1: Read inputs

1. Read `product-requirement-brief.md` in full
2. Read `technical-architecture.md` in full
3. Scan for Storybook stories using `Glob` with pattern `**/*.stories.tsx` — if found, read each file's named exports (story names) to build a component inventory. If no stories exist, note this and continue.

#### Step 2: Decompose into user stories

Analyze the PRB's epics and user stories. For each user story (or tightly coupled group of 2-3 stories that form one vertical slice):

- **id** — slug identifier (e.g., `mobile-task-execution`, `offline-sync`)
- **title** — human-readable name
- **prbRequirements** — list of requirement IDs from the PRB (e.g., `["MN-001", "MN-002"]`)
- **prbSection** — section number in the PRB
- **prbLines** — `{ start, end }` line range in the PRB
- **techArchSections** — relevant sections from technical-architecture.md
- **persona** — primary persona from the PRB
- **priority** — P0, P1, or P2 from the PRB
- **components** — Storybook components that map to this story (from the scan), or empty if no stories exist
- **dependencies** — IDs of other stories that must be completed first
- **description** — one-sentence summary of the value this story delivers

Group related requirements into stories that represent **deliverable increments**:
- Each story should be implementable and testable on its own (given its dependencies are met)
- Prefer fewer, meatier stories over many tiny ones — a story should take 1-3 days of agent work
- Table-stakes requirements that serve as foundations (auth, data model, infrastructure) become their own stories
- Architecture/infrastructure concerns become stories too — they deliver value by unblocking other stories

#### Step 3: Order by dependency and value

Perform a topological sort of the stories by their dependency graph. Within the same dependency tier, order by:
1. P0 before P1 before P2
2. Stories that unblock the most dependents first
3. Foundation/infrastructure stories before feature stories

Assign each story an `order` field (1-indexed) representing its position in the execution sequence.

#### Step 4: Pre-compute batches

Group stories into batches of 4 (the final batch may be smaller). Assign a `batch` field (1-indexed) to each story. Add a top-level `totalBatches` field.

#### Step 5: Write manifest and progress file

Write `refinement-manifest.json`:

```json
{
  "prb": "product-requirement-brief.md",
  "techArch": "technical-architecture.md",
  "storybookInventory": [
    { "component": "FlightBoard", "stories": ["Default", "Loading", "Empty", "Error", "DelayedFlights"] },
    ...
  ],
  "totalStories": 18,
  "totalBatches": 5,
  "reviewEnabled": true,
  "stories": [
    {
      "id": "data-architecture",
      "title": "Data Architecture & Multi-Tenancy",
      "order": 1,
      "batch": 1,
      "priority": "P0",
      "persona": "All",
      "prbRequirements": ["TS-001"],
      "prbSection": "4.X",
      "prbLines": { "start": 200, "end": 220 },
      "techArchSections": ["6", "4.4"],
      "components": [],
      "dependencies": [],
      "description": "Establish tenant-isolated data layer with RLS and audit fields."
    },
    ...
  ]
}
```

Write `refinement-progress.json`:

```json
{
  "phase": "manifest",
  "totalStories": 18,
  "totalBatches": 5,
  "reviewEnabled": true,
  "stories": {
    "data-architecture": { "status": "pending", "batch": 1, "order": 1 },
    "auth-rbac": { "status": "pending", "batch": 1, "order": 2 },
    ...
  }
}
```

#### Step 6: Present for confirmation

Print a summary table:

```
Refinement Manifest
========================================
#   Story                    Priority  Deps              Batch
----------------------------------------
1   data-architecture        P0        —                 1
2   auth-rbac                P0        data-architecture 1
3   mobile-task-execution    P0        auth-rbac         1
4   offline-sync             P0        mobile-task-exec  1
...
========================================
Total: 18 stories | 5 batches | Reviews: enabled
```

Use `AskUserQuestion` to confirm the manifest before proceeding. Allow the user to adjust story grouping or ordering.

---

### Phase 2 — Generate Story Specs (Subagent Delegation)

**Goal:** Generate one implementation spec per user story without exhausting context.

**This phase follows the ultra-lean parent protocol.**

#### Step 1: Load state (once)

1. Read `refinement-manifest.json` — this is the **only** time you read the manifest in Phase 2
2. Read `refinement-progress.json` — identify which stories are `"done"` (from a resumed session)
3. Build the batch plan in memory: for each batch, collect the pending stories and their manifest data

#### Step 2: Create output directory

```
specs/
  stories/
```

#### Step 3: Execute batches

For each batch of up to 4 stories, launch subagents **in parallel** using `Task` with `run_in_background: true` and `subagent_type: "general-purpose"`. Each subagent receives its story data **embedded directly in the prompt** — subagents never read the manifest.

**Subagent prompt template:**

```
You are generating an implementation spec for a user story. This spec must be a complete
vertical slice — UI, API, data, and tests — so that an implementing agent can build and
deliver this story as a working increment.

READ THESE FILES FIRST:
1. {absolute path to spec-template.md} — Follow this template exactly
2. {absolute path to PRB} lines {prbLines.start}-{prbLines.end} — Requirements for this story
3. {absolute path to technical-architecture.md} — Focus on sections: {techArchSections}

STORY DETAILS:
- ID: {id}
- Title: {title}
- Priority: {priority}
- Persona: {persona}
- PRB Requirements: {prbRequirements joined with ", "}
- Tech Arch Sections: {techArchSections joined with ", "}
- Dependencies: {dependencies joined with ", " or "None"}
- Storybook Components: {components joined with ", " or "None identified"}
- Description: {description}

GENERATE the spec following the template. Key rules:
- Copy requirement details VERBATIM from the PRB — user stories, acceptance criteria
- Map to specific technical architecture sections by reference
- Include concrete file paths from the tech architecture
- If Storybook components are listed, reference them and their states
- If this story spans multiple priorities (e.g., P0/P1), include a "## Phase Scope" section
  that separates requirements by phase so implementing agents can work one phase at a time
- Dependencies section must list which story specs must be complete before this one

WRITE the spec to: specs/stories/{id}.md

AFTER WRITING — Self-verify:
1. Read back the file and confirm all template sections are present
2. Verify every PRB requirement ID appears in the spec
3. Verify the dependencies list is correct

THEN update refinement-progress.json:
- Read the current file
- Set stories.{id}.status to "done"
- Set stories.{id}.specFile to "specs/stories/{id}.md"
- Write the file back

Return a single line: "DONE {id}" or "FAIL {id} — {error description}"
```

Set `max_turns: 8` on each subagent.

#### Step 4: Between batches

After all subagents in a batch complete, the parent does **exactly this** and nothing more:

1. **Read `refinement-progress.json`** to confirm batch completion
2. **Print a status line:** `Batch {n}/{total}: {story1} OK, {story2} FAIL`
3. **Launch the next batch** (go to Step 3)

**DO NOT** do any of the following between batches:
- Do NOT read TaskOutput from subagents — the progress file is the source of truth
- Do NOT read any generated spec files — subagents self-verified
- Do NOT re-read the manifest — batch assignments were pre-computed in Step 1

#### Handling failures

If a story has `"status": "pending"` after its batch completes, mark it as `"status": "failed"` in the progress file and move on. Do not retry. The user can re-run the skill and resumability will skip completed stories.

After all batches complete, update the progress file: set `"phase": "specs"`.

---

### Phase 3 — Review Specs (Optional — `--review` flag only)

**Goal:** Have each spec reviewed from two perspectives: architecture and product.

**Skip this entire phase if `--review` was not passed.** Jump directly to Phase 4.

If reviews are enabled, update progress file phase to `"reviews"`.

#### Review agents

For each completed spec, launch **two** review subagents in parallel:

**Architecture Reviewer** (`max_turns: 4`):

```
You are a Technical Architecture Reviewer.

STEPS:
1. Read the spec: specs/stories/{id}.md
2. Read: {absolute path to technical-architecture.md}
3. Review against:
   - NFR coverage — Are relevant NFRs addressed?
   - Data model alignment — Correct entities, relationships, tenant isolation?
   - API consistency — Follows conventions from the tech arch?
   - Security — Auth, encryption, audit logging present where needed?
   - Performance — Will it meet stated targets?
   - Dependencies — Are they accurate and complete?
4. Write review to: specs/reviews/{id}-arch.md

   Format:
   **Reviewer:** Architecture
   **Status:** [Approved / Approved with Concerns / Needs Revision]
   [Findings by criteria. Cite NFR IDs, section numbers. Max 40 lines.]

Return ONLY: "DONE: [STATUS] for {id} arch review"
```

**Product Reviewer** (`max_turns: 4`):

```
You are a Product Manager Reviewer.

STEPS:
1. Read the spec: specs/stories/{id}.md
2. Read: {absolute path to PRB}
3. Review against:
   - Requirement coverage — Every PRB requirement ID accounted for?
   - Acceptance criteria — All AC preserved verbatim and testable?
   - Persona alignment — Correct persona, respects their goals/frustrations?
   - Value delivery — Does this story deliver a working increment?
   - Scope creep — Anything beyond what the PRB defines?
   - Priority accuracy — Matches PRB priority?
4. Write review to: specs/reviews/{id}-pm.md

   Format:
   **Reviewer:** Product Manager
   **Status:** [Approved / Approved with Concerns / Needs Revision]
   [Findings by criteria. Cite requirement IDs, personas, PRB sections. Max 40 lines.]

Return ONLY: "DONE: [STATUS] for {id} pm review"
```

#### Review batches

Process reviews in batches of 4 specs (8 agents — 2 per spec). Create `specs/reviews/` before starting.

After each review batch:
1. For each spec in the batch, read only the first 3 lines of each review file to extract the Status
2. Update the spec file: replace the review placeholder sections with a status line and link:
   ```
   **Status:** Approved with Concerns
   See [Architecture Review](../reviews/{id}-arch.md) for full findings.
   ```
3. Track review statuses in the progress file

After all reviews complete, update progress: set `"phase": "reviews"`.

---

### Phase 4 — Build Implementation Plan

**Goal:** Produce a dependency-ordered implementation plan that agents can execute story by story.

1. Read `refinement-manifest.json` for the story list, ordering, and dependencies
2. Read `refinement-progress.json` for spec completion status and review statuses (if reviews were run)
3. Scan `specs/stories/` with `ls` to confirm which files exist — do NOT read their content

Write `IMPLEMENTATION-PLAN.md` in the same directory as the PRB with these sections:

#### Agent Workflow Protocol

```markdown
## Agent Workflow

### How to Pick a Task

1. Read this plan and find the first unchecked item (`- [ ]`).
2. Verify all dependencies (listed after "Depends on:") are checked (`- [x]`).
3. If multiple items are available, work them in listed order — they are sorted by
   dependency and value.

### How to Execute a Task

1. Open the linked spec file. If it has a `## Phase Scope` section, read only the
   subsection for the current phase.
2. Read the project's CLAUDE.md for repo conventions.
3. Implement the requirements. Run tests. Ensure acceptance criteria pass.

### How to Mark Completion

1. Commit and push following repo conventions.
2. Edit this file: change `- [ ]` to `- [x]` for the completed item.
3. If only one phase of a multi-phase story is done, mark only that entry.
```

#### Story Entries

List every story in dependency/value order. Use this format:

```markdown
- [ ] **1. {id}** — [{title}](specs/stories/{id}.md)
  - **Priority:** P0
  - **Persona:** {persona}
  - **Depends on:** {dependency IDs or "None"}
  - **Review:** Arch: Approved | PM: Approved with Concerns
  - **Value delivered:** {one sentence — what works after this story ships}
```

If reviews were not run, omit the Review line.

For multi-priority stories, create separate entries per phase:

```markdown
- [ ] **7. {id} (P0)** — [{title}](specs/stories/{id}.md#p0-scope)
  - **Priority:** P0
  - **Depends on:** auth-rbac
  - **Value delivered:** Core task execution flow works end-to-end

- [ ] **14. {id} (P1)** — [{title}](specs/stories/{id}.md#p1-scope)
  - **Priority:** P1
  - **Depends on:** {id} (P0), offline-sync
  - **What exists (from P0):** TaskList, TaskDetail, GET /api/v1/tasks
  - **New this phase:** OfflineQueue, ConflictResolver, POST /api/v1/sync
  - **Value delivered:** Tasks work offline with automatic sync
```

#### Cross-Cutting Concerns

After the story list, add a section capturing patterns every implementing agent must follow — pull these from the tech architecture and review findings:

- Tenant isolation rules
- Auth requirements for all endpoints
- Audit logging requirements
- Error handling patterns
- Any other cross-cutting patterns identified

#### Dependency Graph

Include a Mermaid diagram showing story dependencies. Use the story IDs as node labels.

After writing the plan, update progress: set `"phase": "plan"`.

---

### Phase 5 — Finalize

**Goal:** Create the spec index and update CLAUDE.md for agent orientation.

#### Step 1: Spec Index

Create `SPEC-INDEX.md` in the same directory as the PRB:

```markdown
# Spec Index

Quick-reference summary of all story specs. Read the linked spec for full details.

| # | Story ID | Title | Priority | Depends On | Review |
|---|----------|-------|----------|------------|--------|
| 1 | [data-architecture](specs/stories/data-architecture.md) | Data Architecture | P0 | None | Arch: OK / PM: OK |
| 2 | [auth-rbac](specs/stories/auth-rbac.md) | Auth & RBAC | P0 | data-architecture | Arch: OK / PM: OK |
...
```

#### Step 2: Update CLAUDE.md

Read the existing `CLAUDE.md` in the project root. If it does not exist, create it.

Add or update a `## Refinement` section:

```markdown
## Getting Started (for Agents)

This project has been through the refinement pipeline. The `specs/` directory contains
{N} implementation-ready story specifications{, reviewed by architecture and product agents}.

1. Read this file first.
2. Open [IMPLEMENTATION-PLAN.md]({relative path}) and follow the **Agent Workflow** section.
3. Each spec is a vertical slice (UI + API + data + tests) for one user story.
4. Specs with `## Phase Scope` span multiple priorities — read only your current phase.
{5. Review files in `specs/reviews/` provide architecture and product feedback per spec.}
```

**Preserve all existing CLAUDE.md content.** Only add or replace the `## Getting Started (for Agents)` section.

#### Step 3: Report

Print a completion summary:

```
Refinement Complete
========================================
Stories:  18 total | 17 done | 1 failed
Reviews:  34 total | 32 approved | 2 with concerns
Plan:     IMPLEMENTATION-PLAN.md written
Index:    SPEC-INDEX.md written
CLAUDE:   CLAUDE.md updated
========================================
```

Update progress: set `"phase": "complete"`.

---

## Context Window Strategy

This skill is engineered to stay within the ~137k usable context window even for large PRBs.

### Token Budget

| Phase | Operations | Estimated Tokens |
|---|---|---|
| Phase 1 (ingest + manifest) | Read PRB + tech arch + scan stories, write manifest | ~22,000 |
| Phase 2 (generate specs) | Read manifest once, read progress between batches | ~15,000 |
| Phase 3 (reviews, if enabled) | Read progress between batches, edit status lines | ~12,000 |
| Phase 4 (implementation plan) | Read manifest + progress, write plan | ~10,000 |
| Phase 5 (finalize) | Write index + update CLAUDE.md | ~5,000 |
| **Total** | | **~64,000** |

### Protective Rules

1. **Never read TaskOutput** — Subagents return one-line status strings. The progress file is the source of truth.

2. **Never read generated spec files** — Subagents self-verify their work before marking done.

3. **Never re-read the manifest** — Read it once at the start of Phase 2. Batch assignments are pre-computed and held in memory.

4. **Never read review file content** — Only read the first 3 lines for the status. Full review content lives in the files for implementing agents to consult later.

5. **Only read the progress file between batches** — This is the single checkpoint mechanism.

---

## Dependencies

This skill depends on:
- **product-requirements skill** — produces the PRB input
- **technical-architecture skill** — produces the tech arch input
- **storybook-builder skill** (optional) — produces Storybook stories for component mapping

## Reference Files

- `references/spec-template.md` — Template for story specs, used by every spec-generating subagent
